# 모노이드

하스켈에서 타입클래스는 공통적인 어떤 행위들을 가진 타입의 인터페이스를 표현하는데 사용됩니다. 지금까지 우리는 동일한 값인지 비교하는 타입들을 위한 `Eq`, 순서를 가진 타입의 `Ord`에서부터 좀 더 복잡한 행위들을 정의한 `Functor`나 `Applicative` 타입클래스까지 다루었습니다. 

타입을 만들때는 어떤한 행위들을 지원할지를 생각합니다. 타입이 어떤 동작을 할 수 있느냐에 따라서 어떤 타입클래스의 인스턴스로 만들지를 결정합니다. 예를들어 타입의 값들이 같은지 비교하려면, `Eq` 타입클래스의 인스턴스가 되야 합니다. 타입이 어떤 펑터의 일종이라면 `Functor`의 인스턴스가 되어야 합니다.

`*`는 두개의 숫자를 받아서 곱하는 함수 입니다. 만약 어떤 값 `x`와 `1`을 곱하면 결과는 항상 그대로 `x` 를 반환합니다. `1 * x`나 `x * 1`, 순서는 관계없이 결과는 `x` 입니다. 유사하게 `++`는 두개의 리스트를 받아서 결합하는 함수입니다.  그리고 `*`의 1처럼 결과를 바꾸지 않는 입력으로 빈리스트 `[]` 가 있습니다. 

```haskell
ghci> 4 * 1  
4  
ghci> 1 * 9  
9  
ghci> [1,2,3] ++ []  
[1,2,3]  
ghci> [] ++ [0.5, 2.5]  
[0.5,2.5]
```

`*`의 `1`과 `++`의 `[]`는 아래와 같은 공통된 특징을 가지고 있습니다. 

* 두개의 파라메터를 입력으로 받는 함수다.
* 파라메터와 리턴값의 타입이 동일하다.
* 바이너리 함수에 사용됐을때 이미 존재하는 값을 다른 값을 변경하지 않는다.

`*`와 `++`의 또다른 공통된 특징으로 결합 법칙이 있습니다. 여러개의 값으로 하나의 값을 구할때 순서에 관계없이 결과가 동일하다는 점입니다. 즉, `(3 * 4) * 5`와 `3 * (4 * 5)`의 결과는 동일하게 `60` 입니다. `++`도 같은 특징을 가집니다. 

```haskell
ghci> (3 * 2) * (8 * 5)  
240  
ghci> 3 * (2 * (8 * 5))  
240  
ghci> "la" ++ ("di" ++ "da")  
"ladida"  
ghci> ("la" ++ "di") ++ "da"  
"ladida" 
```

이러한 특징을 연관성\(associativity\)라고 부릅니다. `*`와 `++`은 모두 연관성이 있지만, 예를들어 `-`는 `(5 - 3) - 4`와 `5 - (3 - 4)`의 결과값이 다르므로 연관성이 없습니다. 

모노이드\(monoid\)를 이해하는 것은 이러한 특징을 알고 사용하는데서 시작됩니다. 모노이드는 연관 바이너리 함수\(associative binary function\)와 이 함수의 identity로 동작하는 값\(예를들어 `1`이나 `[]`와 같은 값\)을 가질때 사용됩니다. 하스켈에는 매우 다양한 모노이드가 있습니다. 따라서 모노이드와 같은 동작을 가진 `Monoid`라는 타입클래스가 있습니다. 

```haskell
class Monoid m where  
    mempty :: m  
    mappend :: m -> m -> m  
    mconcat :: [m] -> m  
    mconcat = foldr mappend mempty
```

`Monoid`는 `import Data.Monoid`에 정의되어 있습니다.

`Monoid`를 보면 `Functor`나 `Applicative`와 다르게 `m`이 어떤 타입 파라메터도 요구하지 않습니다. 

첫번째 함수인 `mempty` 는 파라메터를 받지 않기때문에 실제로는 함수가 아니고, 다형성 상수 입니다. 다형성 상수를 예를들면 `Bounded`의 `minBound` 같은 것입니다. `mempty`는 어떤 모노이드의 `identity` 값을 나타냅니다. 

{% hint style="info" %}
`Bounded`는 하스켈에서 아래와 같이 정의되어 있습니다. 

```haskell
class  Bounded a  where
 minBound         :: a
 maxBound         :: a
```
{% endhint %}

다음으로 `mappend`는 바이너리 함수입니다. 두 값을 입력받고, 입력값들의 타입이 리턴값의 타입과 같습니다. `mappend`라는 이름은 `++` 처럼 어떤 값에 추가해야할 것 같지만, 실제로는 `*`와 같은 바이너리 함수도 있습니다. 따라서 함수명은 무시하고 두개의 모노이드 값을 받아서 다른 어떤 값을 리턴하는 바이너리 함수로 생각해야 합니다. 

마지막으로 `mconcat` 함수는 모노이드 값의 리스트\(`[m]`\)를 받아서, 리스트의 값들이 `mappend`로 줄여진 값을 반환합니다. `mconcat` 함수의 경우, 기 구현체를 가집니다. 기본 구현체는 `foldr`에 `mappend` 함수와 `mempty`\(초기값\)를 매개변수로 호출했습니다. 대부분의 `Monoid` 인스턴스에 기본 구현체가 적합하기때문에 `mconcat`에 대해서는 크게 신경쓰지 않아도 됩니다. 따라서 `Monoid`의 인스턴스를 만들때 `mempty`와 `mappend`만 작성하는 것으로 충분합니다.  

이게 어떤 `Monoid`의 인스턴스들을 보기전에 모노이드 법칙에 대해서 간단히 살펴보겠습니다. 우리는 이미 identity 값을 가져야하고, 바이너리 함수는 연관성을 가져야 한다고 이야기했습니다. 이러한 규칙을 따르지 않는 `Monoid`의 인스턴스를 만들수는 있지만, 모노이드처럼 동작하지 않을 것이기 때문에 유용하지 않습니다. 따라서 인스턴스를 만들때 아래와 같은 법칙을 따르도록 해야합니다.  

* ``mempty `mappend` x = x``
* ``x `mappend` mempty = x``
* ``(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)``

앞의 두가지 법칙은 `mempty`가 identity로 `mappend`에 입력됐을때, 순서에 관계없이 항상 결과가 동일해야 한다는 것을 말합니다. 그리고 세번째 법칙은 `mappend`가 연관성에 대한 법칙입니다. 즉, 여러개의 값으로 `mappend`를 사용해서 하나의 값을 줄일때 순서에 관계없이 결과가 같아야 합니다. 하스켈에서는 이러한 법칙을 따르도록 강제하지 않았기 때문에 프로그래머가 인스턴스를 만들때 주의해서 작성해야 합니다. 

#### 리스트 모노이드















