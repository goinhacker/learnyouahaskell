## 예외

모든 언어는 실패할수있는 프로시져, 함수 등의 코드를 가지고 있습니다. 그리고 각 언어들은 다른 방법으로 실패에 대한 핸들링을 합니다. C언어의 경우, -1, null가 같은 값을 반환함으로써 함수가 실패했다는 것을 알려줍니다. 반대로 Java나 C#은 예외를 사용하여 실패를 핸들링합니다. 예외가 발생하면 제어의 흐름이 우리가 에러 핸들링을 위해서 정의한 위치로 바뀌게 됩니다. 여기서 예외에 대한 핸들링을 수행합니다. 

하스켈은 `Maybe`나 `Either`와같은 대수적 타입을 사용해서 결과값의 존재 유무를 판단할 수 있습니다. C언어에서 -1을 실패의 의미로 사용합니다. 근데 이것은 사람들끼리의 약속일 뿐이고, 코드를 작성할때 주의하지 않으면 -1값을 정상값처럼 취급할 수도 있습니다. 하스켈의 타입 시스템은 이런 측면에서 더 안전하게 핸들링할 수 있도록 합니다. `a -> Maybe b`는 `Just`에 랩핑된 `b`이거나 `Nothing`을 반환합니다.

하스켈은 실패한 계산을 표현하는 타입을 가지고 있음에도 불구하고, I/O 문맥에서 더 이해하기 쉽기때문에 예외도 제공합니다. 예를들어 파일을 여는 것과 같이 외부의 어떤 것을 다룰때는 어떤 동작을 할지 신뢰할 수 없습니다. 파일이 락에 걸려있을수도 있고, 파일이 없을수도 있습니다. 따라서 이러한 오류가 발생할 경우, 오류를 핸들링하기 위한 부분으로 제어흐름을 이동시키는 것이 좋습니다. 

I/O 코드(순수하지 못한 코드)는 예외를 발생시킬수 있습니다. 그렇다면 순수한 코드에서는 어떨까요? 순수한 코드에서도 예외가 발생할 수 있습니다. `div`, `head` 함수의 타입은 각각 `(Integral a) => a -> a -> a`와 `[a] -> a` 입니다. `Maybe`나 `Either`를 반환하지 않습니다. 하지만 이 함수들을 실패할 수 있습니다. `div` 함수는 0으로 나누면 실패하고, `head` 함수는 리스트가 비어있을때 실패할 것 입니다. 

```haskell
**[terminal]
**[prompt ghci> ]**[command 4 `div` 0]
*** Exception: divide by zero
**[prompt ghci> ]**[command head []]
*** Exception: Prelude.head: empty list
```

위와같이 **순수한 코드도 예외를 발생시킬수있다. 그러나 I/O 영역에서만 catch할 수 있다.** 즉, `main` 함수내의 _do_ 블럭 안에서 catch할 수 있다. **I/O 영역에서만 예외를 잡을 수 있는 이유는 순수한 코드는 어떤 값이 평가되는 시점을 알 수가 없기때문이다.** 순수한 코드는 lazy한 특성때문에 I/O 코드와는 달리 정의된 실행 순서가 없고, 따라서 예외를 잡을 수 없다. 

이전에 프로그램에서 가능한 I/O 부분에서 적은 시간을 보내야 한다고 했었습니다. 순수한 함수는 그 결과가 입력 매개변수에만 의존하기 때문에, 프로그램의 로직은 대부분 순수한 함수안에 있어야 합니다. 순수한 함수는 다른 일을 할 수 없기때문에 그 함수가 반환하는 것만 생각하면 됩니다. I/O에도 약간의 로직(파일열기 등)이 필요하긴 하지만 최소한의 유지해야 합니다. 순수한 함수는 기본적으로 게으르고, 언제 평가될지 알 수도 없고, 그게 중요하지도 않습니다. 그러나 순수한 함수가 예외를 던질때는, 평가되는 시점이 중요합니다. 그래서 순수한 함수로부터 발생한 예외는 I/O 부분에서만 catch할 수 있습니다. 그런데 여기서 모순이 생깁니다. 가능한 I/O 부분을 줄여야하지만 예외는 I/O 부분에서만 잡을 수 있습니다. 그렇다고 I/O 부분을 줄이기 위해서 예외를 잡지않으면 프로그램이 죽을 것 입니다. 이에대한 해결방법은 **예외와 순수한 코드를 섞지 않는 것 입니다.** 하스켈의 타입시스템에서 제공하는 `Either`와 `Maybe`를 사용하여 실패할 수 있는 결과를 표현합니다. 

여기서는 I/O 예외를 사용하는 방법에 대해서 알아볼 것 입니다. I/O 예외는 `main`의 부분인 I/O 작업안에서 외부와 커뮤니케이션하는 동안 무언가 잘못되면 발생하는 예외입니다. 예를들어 파일을 열고나서야 파일이 삭제되었는지 있는지를 판단할 수 있습니다. 아래 프로그램을 보자. 

```haskell
import System.Environment  
import System.IO  
  
main = do (fileName:_) <- getArgs  
          contents <- readFile fileName  
          putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"
``` 

커맨드라인에서 입력받은 이름을 가진 파일을 열고, 파일에 라인수를 출력하는 프로그램입니다. `getArgs`의 첫번째 문자열만 `fileName`에 바인딩하고, 파일을 읽어서 `contents`에 바인딩 합니다. 마지막으로 `lines` 함수에 `contents`를 넣어서 라인단위로 분리하고, 분리된 리스트의 길이를 계산합니다. 여기서 만약 존재하지않는 파일명을 입력으로 준다면 어떻게 될까요? 

```haskell
**[terminal]
**[prompt $ ]**[command runhaskell linecount.hs i_dont_exist.txt]
linecount.hs: i_dont_exist.txt: openFile: does not exist (No such file or directory)
``` 

에러가 발생했고, 파일이 존재하지 않는다는 내용을 출력했다. 프로그램은 크래쉬가 발생하여 종료되었다. 파일이 없으면 적당함 메시지를 출력하도록 하겠습니다. 한가지 방법은 파일을 열기전에 파일의 존재 여부를 확인하는 것 입니다. `System.Directory`의 `doesFileExist` 함수를 사용하면 파일의 존재 여부를 체크할 수 있습니다.

```haskell
import System.Environment  
import System.IO  
import System.Directory  
  
main = do (fileName:_) <- getArgs  
          fileExists <- doesFileExist fileName  
          if fileExists  
              then do contents <- readFile fileName  
                      putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"  
              else do putStrLn "The file doesn't exist!"
```

`doesFileExist` 함수의 타입은 `doesFileExist :: FilePath -> IO Bool` 입니다. 따라서 `fileExists <- doesFileExist fileName`와 같이 실행하였습니다. 이 함수는 파일의 존재여부를 알려주는 `Bool`를 가진 I/O 작업을 반환합니다. 그리고나서 if else 구문을 사용하여 적절한 메시지를 출력하였습니다. 

위와 다른 방법으로 예외를 사용할 수 있습니다. 위 프로그램에서 그대로 사용될 수 있습니다. 파일이 없어서 발생되는 예외는 I/O에서 발생하는 예외이므로 I/O에서 잡는 것이 좋습니다. 
 






