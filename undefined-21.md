# 모나드 법칙

펑터나 애플리케이티브 펑터처럼 모나드도 모든 모나드가 지켜야 하는 몇가지 법칙이 있다. 어떤 타입이 `Monad` 타입클래스의 인스턴스가 되었다고 해서 모나드가 되는 것은 아니다. 진정한 모나드가 되려면, 그 타입이 모나드의 법칙을 만족해야 한다. 이 법칙은 타입과 타입이 가진 행위에 대해서 합리적인 가정을 가능하게 합니다. 

하스켈에서 모든 타입이든 어떤 타입클래스의 인스턴스가 될 수 있습니다. 하지만 타입이 모나드의 법칙들을 만족하는지는 체크해주지 않습니다. 따라서 어떤 `Monad` 타입클래스의 인스턴스인 타입을 만들었다면, 직접 모든 모나드 법칙들을 만족하는지 수동으로 확인해 보아야 합니다. 

### Left Identity

첫번째 모나드 법칙은 아래와 같습니다.

**`return x >>= f`는 `f x`와 같다.**

어떤 값을 컨텍스트에 넣고, 해당 값을 일반 값을 매개변수로 받는 함수에 적용한 결과는 그냥 일반 값을 넣어서 함수에 적용한 결과 같습니다. Maybe 모나드가 이 법칙에 만족하는지 확인할 수 있습니다. 

```haskell
ghci> return 3 >>= (\x -> Just (x+100000))  
Just 100003  
ghci> (\x -> Just (x+100000)) 3  
Just 100003 
```

리스트 모나드에서 `return`은 싱글 리스트에 값을 넣습니다. `>>=`는 리스트에 모든 값에 대해서 함수에 적용합니다. 하지만 리스트에 값이 하나밖에 없는 경우에는 그냥 함수에 일반 값을 적용한 것과 같습니다.

```haskell
ghci> return "WoM" >>= (\x -> [x,x,x])  
["WoM","WoM","WoM"]  
ghci> (\x -> [x,x,x]) "WoM"  
["WoM","WoM","WoM"]
```

`IO`도 `return`을 쓰면 부수효과없이 값의 있다는 것만 나타내는 I/O 작업이 생성됩니다. 따라서 `IO`도 이 법칙에 만족합니다.

### Right Identity

두번째 모나드 법칙을 아래와 같습니다. 

**`m >>= return`는 `m`과 같다.**

`>>=`는 모나드값을 함수에 적용합니다. `return`도 일종의 함수라서 모나드값이 입력으로 들어가면 그대로 다시 컨텍스트에 담아서 반환합니다. 따라서 모나드값이 컨텍스트에 담겨진 `m`과 같습니다. 몇가지 모나드가 법칙에 만족하는지 확인해보겠습니다.

```haskell
ghci> Just "move on up" >>= (\x -> return x)  
Just "move on up"  
ghci> [1,2,3,4] >>= (\x -> return x)  
[1,2,3,4]  
ghci> putStrLn "Wah!" >>= (\x -> return x)  
Wah! 
```

리스트 모나드의 `>>=` 함수를 다시한번 살펴보면 아래와 같습니다.

```haskell
xs >>= f = concat (map f xs)  
```

따라서 `[1,2,3,4]`를 `return`에 입력으로 넣으면, 먼저 맵핑되서 `[1],[2],[3],[4]`가 되고, 이걸 다시 `concat`으로 붙여서  `[1,2,3,4]`가 됩니다.

`Left identity`와 `Right identity`는 `return`이 어떻게 동작하는지에 대한 법칙입니다. `return` 함수는 값을 모나드로 만드는 중요한 함수입니다. 일단 모나드가 되고 나면 다른 것들과 섞어서 사용하는 것은 좋지 않습니다.

### Associativity

모나드의 마지막 법칙은 아래와 같습니다. 

`(m >>= f) >>= g`는 `m >>= (\x -> f x >>= g)`과 같다.

여기서는 한개의 모나드값 `m`과 두개의 모나드 함수가 있습니다. `(m >>= f) >>= g`를 수행하면, `f`에 `m`이 입력되고 결과는 모나드값이 됩니다. 그리고 나서 이 모나드값을 `g`에 넣습니다. `m >>= (\x -> f x >>= g)`에서는 모나드값을 하나 받아서 함수에 넣고, `f x`의 결과를 `g`에 넘깁니다. 이 두가지가 왜 같은지 좀 더 명확히 하기 위해서 줄타기 예제를 다시하번 보겠습니다. 

```haskell
ghci> return (0,0) >>= landRight 2 >>= landLeft 2 >>= landRight 2  
Just (2,4)  
```

이 예제에 괄호를 넣어보겠습니다. 

```haskell
ghci> ((return (0,0) >>= landRight 2) >>= landLeft 2) >>= landRight 2  
Just (2,4)  
```

이 것은 아래와 같이 재작성할 수 있습니다. 

```haskell
return (0,0) >>= (\x -> 
landRight 2 x >>= (\y -> 
landLeft 2 y >>= (\z -> 
landRight 2 z)))  
```

`return (0,0)`은 `Just(0,0)`가 되므로 법칙의 우변과 동일합니다. 두 방식은 모두 결과가 같으므로 법칙을 만족하는 것을 보입니다. 

결론적으로 모나드 함수에 값을 전달하는 것은 어떤식으로 중첩되어 있든 관계가 없습니다.  아래 예제를 통해서 법칙을 `f`와 `g`의 합성으로 확인해보겠습니다.

```haskell
(.) :: (b -> c) -> (a -> b) -> (a -> c)  
f . g = (\x -> f (g x))  
```

`g`의 타입이 `a -> b`이고, `f`의 타입이 `b -> c`라면, 합성 함수의 타입은 `a -> c`가 될 것입니다. 여기서 두 함수가 모나드라면, 즉 모나드를 반환하는 함수라고 가정해보겠습니다. `g` 함수의 타입이 `a -> m b`이고 `f`의 타입이 `b -> m c`일때, `g`의 결과값이 `f`에 입력될 수 없습니다. 따라서 `==>`를 사용해서 재작성하면 아래와 같습니다. 

```haskell
(<=<) :: (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c)  
f <=< g = (\x -> g x >>= f)  
```

이제 두 모나드 함수를 합성할 수 있습니다. 

```haskell
ghci> let f x = [x,-x]  
ghci> let g x = [x*3,x*2]  
ghci> let h = f <=< g  
ghci> h 3  
[9,-9,6,-6]  
```

이게 Associativity 법칙과 어떤 관계가 있을까요? 합성의 관점에서 법칙을 보면 `f <=< (g <=< h)`와 `(f <=< g) <=< h`는 같습니다. 이것은 모나드의 경우, 동작의 중첩은 중요하지 않다는 것을 증명하는 또다른 방법입니다.

`<=<`을 사용해서 처음 두법칙을 설명하면, 모든 모나드 함수 `f`에 대해서 `f <=< return`은 `f`와 같고, `return <=< f`도 `f`와 같으므로 모두 만족한다고 할 수 있다. 

`f`가 그냥 일반 함수라고 해도 매우 유사하다. `(f . g) . h`는 `f . (g . h)`와 같고, `f . id`는 `f`와 같으며, `id . f`도 `f`와 같다. 

이번 장에서 우리는 모나드의 기초를 살펴보고 Maybe 모나드와 리스트 모나드가 어떻게 작동 하는지를 배웠습니다. 다음 장에서는 다른 모나드를 살펴보고 직접 만들어 볼 것 입니다.

