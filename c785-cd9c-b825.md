# 입출력 Hello, world!

하스켈은 순수한 함수형 언어입니다. 명령형 언어에서는 실행하기위한 단계 절차를 주는 반면에 함수형 언어는 어떤 일을 하는지 정의해야 합니다. 하스켈에서 함수는 변수의 내용을 바꾸는 것과 같이 어떤 상태를 바꿀 수 없습니다(상태가 변화하는 함수는 side-effect를 가지고 있다고 함). 함수는 주어진 입력을 기반으로 어떤 결과를 돌려주는 역할만 할 뿐입니다. 만약 동일한 파라메터로 2번 호출된다면 반드시 같은 결과를 돌려줄 것입니다. 명령형 프로그래밍에 익숙한 프로그래머는 함수의 활용을 제한하는 것으로 느낄 수 있지만, 함수의 상태를 바꾸지않는 것이 실제로 어떻게 좋은 것인지 지금까지 살펴보았습니다. 명령형 프로그래밍에서는 주어진 입력에 대해서 내부적으로 어떤 상태 변화가 있을지 알 수 없습니다. 예를들어 함수형 프로그래밍에서는 이진 검색 트리에 새로운 노드를 넣을때도 기존 트리의 상태를 변경하지 않습니다. 즉, 새로운 노드가 삽입될때 기존 트리를 변형하지 않고, 새로운 트리를 만들어서 리턴합니다. 

함수가 상태를 변경할 수 없는 것이 좋은 이유는 알았지만, 한가지 문제가 있습니다. 만약 함수가 어떤 것도 바꿀 수 없다면, 함수에 의해서 계산된 것이 무엇인지 어떻게 알려줄 수 있을까요? 계산 결과를 알려주기 위해서는 출력 디바이스를 변경해야 합니다(보통 출력 방향을 스크린으로 변경). 

하스켈은 프로그램의 순수한 부분과 상태를 변경해야하는 순수하지 못한 부분(side-effect가 존재하는 부분)을 깔끔하게 분리해서 처리하는 매우 똑똑한 시스템을 가지고 있습니다. 분리된 두 부분으로 게으른 평가(laziness), 견고성(robustness), 모듈성과 같은 순수한 함수형 프로그래밍이 제공하는 모든 장점을 활용하여 외부 컴포넌트와 커뮤니케이션할 수 있습니다.

## Hello, world 프로그램

지금까지는 테스트를 위해서 GHCI내에서 함수를 로딩하고 실행하였습니다. 이제부터는 실제 하스켈 프로그램을 만들어 실행할 것 입니다. 이번 챕터에서는 "hello, world" 프로그램을 만들어 보겠습니다. 

> 여기서부터 작성하는 프로그램은 선호하는 Editor 사용해도 되지만, 프로그램을 실행하기 위해서 Linux-like 환경을 가정합니다. 윈도우 환경이라면 Cygwin을 설치해서 사용하거나, Windows 10의 Linux Shell을 활용할 것은 권장합니다. 

```haskell
main = putStrLn "hello, world"
```

위와같이 작성하고 `helloworld.hs` 파일로 저장합니다.

```haskell
**[terminal]
**[prompt $ ]**[command ghc --make helloworld]
[1 of 1] Compiling Main             ( helloworld.hs, helloworld.o )
Linking helloworld ...
```

터미널에서 `helloworld.hs` 파일이 위치한 디렉토리로 이동한 후, 위와같이 실행하여 컴파일합니다. 

```haskell
**[terminal]
**[prompt $ ]**[command ./helloworld]
hello, world
```

컴파일이 완료되면 `./helloworld`로 실행할 수 있습니다. 

이제 helloworld 예제에서 사용된 `putStrLn` 함수에 대해서 살펴보겠습니다. 

```haskell
**[terminal]
**[prompt ghci> ]**[command :t putStrLn]
putStrLn :: String -> IO ()
**[prompt ghci> ]**[command :t putStrLn "hello, world"]
putStrLn "hello, world" :: IO ()
```

`putStrLn`은 문자열을 입력받아서 결과 타입에 `()`를 포함한 *I/O 작업*을 리턴한다는 것을 알 수 있습니다(비어있는 튜플 `()`은 unit이라고 함). I/O 작업은 실행될때, 어떤 side-effect(입력에서 읽거나, 화면에 출력하는 것)를 수행하고 내부에 어떤 리턴 값을 포함합니다. 문자열을 터미널에 출력하는 것은 실제로 어떤 의미있는 리턴값을 가지고 있지 않기때문에, 더미 값으로 `()`가 사용됩니다. 

> 빈 튜플은 `()`의 값이고 또한 `()`을 타입으로 가집니다. 

I/O 작업은 `main`이라는 이름으로, 프로그램을 실행해야 수행됩니다. 이것은 마치 프로그램 전체에서 I/O 작업을 하나로 제한하는 것처럼 보입니다. 그래서 *do 구문_을 사용하여 여러 I/O 작업들을 하나로 결합할 수 있습니다.* 

```haskell
main = do  
    putStrLn "Hello, what's your name?"  
    name <- getLine  
    putStrLn ("Hey " ++ name ++ ", you rock!")
```

마치 명령형 프로그램처럼 보입니다. _do_를 사용한 이후에는 명령형 프로그램처럼 수행해야하는 단계별로 작성하였습니다. 그리고 각 I/O 작업들은 _do_ 문법에 의해서 하나의 I/O 작업으로 묶입니다. 하나로 묶인 I/O 작업의 타입은 마지막 I/O 작업의 타입인 `IO ()`가 됩니다. 

이런 이유로 `main`의 타입은 항상 `main :: IO something`이 됩니다. 여기서 `something`은 어떤 구체적인 타입입니다. 관례적으로 `main`에 대해서는 타입 선언을 별도로 명시하지 않습니다. 

여기서 `name <- getLine`은 입력 라인을 읽어서 `name` 변수에 저장하는 것처럼 보입니다. 정말 그런지 확인해 보겠습니다. 

```haskell
**[terminal]
**[prompt ghci> ]**[command :t getLine]
getLine :: IO String
```

`getLine`의 타입을 보면 I/O 작업이고 `String` 결과 타입을 포함하고 있습니다. 이것은 사용자가 터미널에서 무언가를 입력할때까지 기다렸다가 문자열로 표시될 것이기 때문입니다. 그렇다면 `name <- getLine` 다음에는 무슨 일이 일어날까요? `name <- getLine` 코드를 그대로 읽으면 *getLine I/O 작업을 수행하고 결과 값을 name에 바인딩한다*입니다. `getLine`의 타입은 `IO String`이므로 `name`의 타입은 `String`일 것입니다. 

I/O 작업은 다른 세상에서 어떤 작업을 수행하고 데이터를 가져올 수 있는 다리가 있는 상자에 비유할 수 있습니다. 한번 데이터를 가져오면 상자를 열고 그 안에있는 데이터를 가져오는 유일한 방법은 `<-`를 사용하는 것 입니다. I/O 작업에서 데이터를 가져오는 경우 다른 I/O 작업을 수행할 때만 데이터를 가져올 수 있습니다. 이것이 하스켈에서 순수한 코드와 그렇지 않은 코드를 깔끔하게 분리하는 방법입니다.    

`getLine`은 결과 값이 두번 수행될때 동일한 결과를 보장하지 않으므로 순수하지 못합니다. 이것이 `getLine` 함수가 I/O 타입 생성자로 오염된(tainted) 이유이고, I/O 코드에서만 해당 데이터를 가져올 수 있습니다. 또한 I/O 코드는 오염되어 있기 때문에 오염된 I/O 데이터에 의존하는 계산은 순수하지 못한 결과를 가져옵니다. 
  
여기서 오염된(tainted)것은 순수한 코드에서 I/O 작업에 포함된 결과를 절대로 사용하지 못한다는 것을 의미하진 않습니다. I/O 작업을 `name`에 바인딩할 때, 일시적으로 I/O 작업 내의 데이터를 오염시키지 않습니다(un-taint). `name <- getLine`을 실행할때, I/O 작업내에서 `name`는 그냥 일반적인 문자열이기 때문입니다. 

```haskell
main = do  
    putStrLn "Hello, what's your name?"  
    name <- getLine  
    putStrLn $ "Read this carefully, because this is your future: " ++ tellFortune name
```

매개변수로 이름을 받아서 이름에 따른 운명과 생애를 알려주는 함수입니다.
여기서 `tellFortune`(또는 `name`을 인자로 받는 어떤 함수)는 I/O에 대해서 어떤 것도 알 필요가 없습니다. 일반적인 `String -> String` 함수입니다. 

```haskell
nameTag = "Hello, my name is " ++ getLine
```

이 코드는 문제가 없을까요? `++` 함수는 동일한 타입의 리스트 두개를 파라메터로 받아야 하기 때문에 동작을 하지 않습니다. 왼쪽 파라메터는 `String` 타입이지만, `getLine`의 타입은 `IO String`입니다. 문자열과 I/O 작업은 연결할 수 없습니다. 먼저 String 타입의 값을 얻기 위해 I/O 작업의 결과를 가져와야 합니다. 이렇게 하려면 다른 I/O 작업의 내부에서 `name <- getLine`와 같은 것을 해야합니다. 순수하지 못한 데이터를 다루려면, 순수하지 못한 환경에서 해야만 합니다. 순수하지 못한 데이터를 다루기 시작하면, 순수하지 못한 코드가 여기저기 퍼져나가게 됩니다. 따라서 이런 순수하지 못한 코드를 작성하는 것을 최소화 해야합니다. 








