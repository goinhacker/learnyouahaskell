# 모나드 타입클래스

`Functor`와 `Applicative` 타입클래스가 있듯이, 모나드도 `Monad`라는 타입클래스가 있습니다~~

```haskell
class Monad m where  
    return :: a -> m a  
  
    (>>=) :: m a -> (a -> m b) -> m b  
  
    (>>) :: m a -> m b -> m b  
    x >> y = x >>= \_ -> y  
  
    fail :: String -> m a  
    fail msg = error msg
```

먼저 첫번째 라인 `class Monad m where`부터 살펴보겠습니다. 분명 모나드는 애플리케이티브 펑터를 업그레이드한 것이라고 했는데, 왜 아래와 같이 선언되지 않았을까요? 

`class (Applicative m) = > Monad m where`

이것은 하스켈이 처음 만들어졌을때는 애플리케이티브 펑터가 하스켈에 적합하다는 것을 몰랐기 때문이라고 합니다. 즉, 하스켈 초기에는 애플리케이티브 펑터가 없었기 때문에 이렇게 작성되어 있는 것 입니다. 하지만, 전에도 말했듯이 모든 `Monad`는 `Applicative`입니다. 

Monad의 첫번째 함수는 `return`입니다. 이것은 이름은 다르지만 `Applicative`의 `pure`와 동일합니다. 이 함수의 타입은 `(Monad m) => a -> m a`입니다. 어떤 값을 받아서 최소한의 기본 컨텍스트\(minimal default context\)안에 값을 넣어줍니다. 즉, 어떤 것을 받아서 모나드로 래핑해줍니다. 우리는 이미 `IO`에서 `return`을 본적이 있습니다. 어떤 값을 받아서 아무것도 하지않는 `IO` 작업으로 만들때 사용했습니다. `Maybe`에서는 값을 받아서 `Just`를 래핑하게 됩니다. 

{% hint style="info" %}
전에도 언급했지만 `return` 함수는 다른 언어들의 `return`과는 전혀 다릅니다.
{% endhint %}

다음 함수는 바인드\(bind\)라고 불리는, `>>=` 입니다. 일반적인 함수와 달리, 모나드값\(즉, 컨텍스트가 있는 값\)을 받아서 정상 값을 받지만 모나드를 반환하는 함수로 전달합니다. 

다음은 `>>` 함수입니다. 이 함수는 기본 구현체가 타입클래스에 있고, 모나드 인스턴스를 만들때 구현하지 않기때문에 자세하게 알 필요는 없습니다. 

마지막 함수는 `fail` 입니다. 이 함수는 코드에서 명시적으로 사용하진 않습니다. 대신 나중에 모나드를 위한 특수한 구문에서 하스켈이 실패를 한것을 표시\(enable0\)하기위해서 사용합니다. 지금은 `fail`에 대해서는 신경쓰지 않아도 됩니다. 

이제 `Monad` 타입클래스가 어떻게 생겼는지 알았습니다. 다음 절에서는 간단히 `Maybe`를 `Monad`의 인스턴스로 만들어보고, 이를 활용한 예제를 살펴보겠습니다. 





















