
# Functors, Applicative Functors and Monoids

하스켈의 순수성, 고차함수, 매개변수화된 대수적 데이터 타입, 타입클래스의 조합은 다른 언어보다 훨씬 고차원의 다형성을 구현 가능하게 합니다. 타입들의 큰 계층 구조를 가지는 타입에 대해서 생각할 필요가 없습니다(마치 Java의 객체의 계층구조와 같은...). 대신 어떤 타입이 어떤 타입클래스와 연결되어있고, 어떤 동작들을 할 수 있는지 알고있으면 됩니다. 예를들어 `Int`는 같은 비교하거나, 순서를 정하는 등의 많은 동작들을 할 수 있습니다.

타입클래스는 오픈되어 있기때문에 자신만의 타입을 정의할 수 있습니다. 정의하려는 타입을 어떤 타입클래스에 연결하는지에 따라서 해당 타입의 동작을 정의할 수 있습니다. 하스켈의 강력한 타입시스템으로 인해 타입 선언을 알기만하면 함수에 대해서 많은 것을 알 수 있습니다. 따라서 상당히 일반적이고 추상적인 동작을 정의한 타입클래스를 만들 수 있습니다. 예를들어 값이 같은지 확인하거나 순서를 비교할 수 있는 타입클래스는 매우 추상화된 동작입니다. 하지만 항상 사용해왔기때문에 특별하게 느껴지지 않습니다. 이전에 살펴본 펑터도 매핑할 수 있는 것이라는 동작을 가진 타입클래스 입니다. 펑터도 유용하면서도 매우 추상적인 타입클래스를 설명해주는 예입니다. 이번 챕터에서는 이 펑터에 대해서 자세히 알아보겠습니다. 또한 펑터의 좀더 유용하고 강력한 버전인 실용적인 펑터(Applicative Functors)와 모노이드(Monoids)에 대해서도 살펴볼 것 입니다.

## Functor

우리는 이미 [타입클래스 챕터](https://jaeyongcho.gitbooks.io/learnyouahaskell/content/d0c0-c785-d074-b798-c2a4.html)에서 펑터에 대해서 공부했습니다. 기억이 안난다면 간단히 복습해볼 것을 권장합니다. 

간단히 리마인드 해보면, 평터는 리스트, `Maybe`, 트리와 같이 맵핑할 수 있는 것 입니다. `Functor` 타입클래스는 `fmap`이라는 함수 한개를 가집니다. `fmap` 함수의 타입은 `fmap :: (a -> b) -> f a -> f b` 입니다. 타입의 의미는 `a`를 받아서 `b`를 반환하는 함수와 `a` 한개 또는 여러개를 담은 박스를 받아서 `b`를 한개 또는 여러개 담은 박스를 반환합니다. 박스안에 아이템은 입력받은 함수가 적용된다. 

> 주의: 직관적으로 펑터가 하는 일에 대한 이해를 돕기위해서, 주로 박스에 비유합니다. 뒤에서 배울 실용적인 펑터나 모나드를 설명할때도 박스를 사용할 것 입니다. 사람들이 펑터를 처음 이해하기에 박스는 괜찮은 비유입니다. 하지만 그것을 그대로 받아들여선 안됩니다. 왜냐하면 어떤 펑터에 대해서는 상자 비유가 완전히 적합하지 않기때문입니다. 펑터의 좀 더 정확한 단어는 computational context 입니다. 이 context에서 computation은 `Maybe`나 `Either a`처럼 값을 가지거나 실패했을 수도 있고, 리스트처럼 여러개의 값을 가질 수 있는 것 입니다.

타입 생성자를 `Functor`의 인스턴스로 만들고 싶다면, kind는 `* -> *`가 됩니다. 즉, 하나의 구체적인 타입만 타입 파라메터로 받는다는 것 입니다. 예를들어 `Maybe`는 인스턴스로 만들 수 있습니다. 왜냐하면 `Maybe Int`나 `Maybe String`처럼 구체적인 타입으로 만들기 위해서 하나의 타입 파라메터만 필요하기 때문입니다. 만약 `Either`처럼 두개의 파라메터가 필요하면, 타입 파라메터가 한개가 될때까지 부분적용해야 합니다. 따라서 `instance Functor Either where`와 같이 작성할 수 없고, `instance Functor (Either a) where`와 같이 작성해야 합니다. 그리고나서 `Either a`만을 위한 `fmap` 함수를 선언하면 `fmap :: (b -> c) -> Either a b -> Either a c`가 됩니다. 타입 선언에서 알 수 있듯이 `Either a` 부분은 고정되어 있습니다. 왜냐하면 `Either a`는 한개의 타입 파라메터만 받는 반면에 `Either`는 두개를 받기 때문입니다. 따라서 `fmap :: (b -> c) -> Either b -> Either c`와 같이 작성할 순 없습니다. 

지금부터 얼마나 많은 타입(실제로는 타입 생성자)들이 `[]`, `Maybe`, `Either a`, `Tree처럼 `Functor`의 인스턴스인지 배워보겠습니다. 먼저 `IO`와 `(->) r`이라 불리는 펑터의 인스턴스에 대해서 알아보겠습니다. 

만약 어떤 값이 `IO String` 타입이면, 외부에서 문자열을 가져오는 IO 작업이라는 의미입니다. `IO String`의 결과를 어떤 이름에 바인딩하기 위해서는 _do_안에서 `<-`를 사용해야 합니다. 









